use async_trait::async_trait;
use pyo3::{
    prelude::*,
    types::{IntoPyDict, PyModule},
};
use std::collections::HashMap;
use std::fs;
use std::path::Path;
use zenoh_flow::async_std::sync::Arc;
use zenoh_flow::zenoh_flow_derive::ZFState;
use zenoh_flow::{Data, Node, PortId, Source, State, ZFError, ZFResult};
use zenoh_flow_example_types::ZFUsize;

#[derive(ZFState, Clone)]
struct PythonState {
    pub module: Arc<Py<PyModule>>,
    pub py_state: Arc<Py<PyAny>>,
}
unsafe impl Send for PythonState {}
unsafe impl Sync for PythonState {}

impl std::fmt::Debug for PythonState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("PythonState").finish()
    }
}

#[derive(Debug)]
struct PythonSource;

#[async_trait]
impl Source for PythonSource {
    async fn run(&self, _context: &mut zenoh_flow::Context, state: &mut State) -> ZFResult<Data> {
        let gil = Python::acquire_gil();
        let py = gil.python();
        let current_state = state.try_get::<PythonState>()?;

        let source_class = current_state
            .module
            .getattr(py, "PySource")
            .map_err(|e| ZFError::InvalidData(e.to_string()))?;

        let value: usize = source_class
            .call_method(
                py,
                "run",
                (source_class.clone(), "", current_state.py_state.as_ref().clone()),
                None,
            )
            .map_err(|e| ZFError::InvalidData(e.to_string()))?
            .extract(py)
            .map_err(|e| ZFError::InvalidData(e.to_string()))?;
        Ok(Data::from::<ZFUsize>(ZFUsize(value)))
    }
}

impl Node for PythonSource {
    fn initialize(&self, configuration: &Option<HashMap<String, String>>) -> State {
        pyo3::prepare_freethreaded_python();
        let gil = Python::acquire_gil();
        let py = gil.python();
        match configuration {
            Some(configuration) => {
                let script_file_path = Path::new(configuration.get("python-script").unwrap());
                let mut config = configuration.clone();
                config.remove("python-script");

                let code = read_file(script_file_path);
                let module = PyModule::from_code(py, &code, "source.py", "source").unwrap();

                let node_class = module.getattr("Node").unwrap();
                let state: Py<PyAny> = node_class
                    .call_method("initialize", (node_class, config), None)
                    .unwrap()
                    .into();

                State::from(PythonState {
                    module: Arc::new(module.into()),
                    py_state: Arc::new(state),
                })
            }
            None => panic!("Missing configuration"),
        }
    }

    fn finalize(&self, _state: &mut State) -> ZFResult<()> {
        Ok(())
    }
}

// Also generated by macro
zenoh_flow::export_source!(register);

fn register() -> ZFResult<Arc<dyn Source>> {
    Ok(Arc::new(PythonSource) as Arc<dyn Source>)
}

fn read_file(path: &Path) -> String {
    fs::read_to_string(path).unwrap()
}
